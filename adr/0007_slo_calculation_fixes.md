# ADR-0007: SLO Calculation Fixes

## Status

accepted

## Context

The original SLO calculations in `internal/helpers/prometheus_helper.go` had several critical flaws that produced incorrect alerting and measurements:

### Issues Found

1. **CRITICAL: Extended Window Recording Rules Broken**
   - Used `increase()` on base window recording rules (gauges)
   - `increase(gauge[1h])` gives change in gauge value, not total events
   - Resulted in meaningless data for longer windows

2. **CRITICAL: Burn Rate Formula Incorrect**
   - Original: `error_budget_value / error_budget_target`
   - This calculated instantaneous error rate multiple, not burn rate
   - Proper burn rate should track how fast error budget is being consumed

3. **HIGH: Division by Zero**
   - No validation for target = 1.0 (100% SLO)
   - When target = 1.0, `error_budget_target = 1 - 1 = 0`
   - Division by zero produced `+Inf` or `NaN`

4. **HIGH: Wrong Window Pairs for Multi-Burn-Rate Alerts**
   - Original: single window checks with wrong thresholds
   - SRE best practice requires paired windows (short + long)
   - Pairs needed: (5m, 1h), (30m, 6h), (2h, 24h), (6h, 3d)

5. **MEDIUM: No Counter/Gauge Handling**
   - All metrics treated as counters with `rate()`
   - Gauge metrics require `avg_over_time()` instead
   - SLI spec has `Counter bool` field that was ignored

6. **MEDIUM: Missing Label Consistency**
   - Burn rate calculations didn't preserve labels
   - Could cause incorrect aggregations with multiple SLI instances

7. **LOW: Empty Rules Validation**
   - No validation of required recording rules before alert generation
   - Could generate invalid PromQL expressions

## Decision

### 1. Per-Window Rate Calculation
Each window now calculates error ratio independently from raw metrics:

```promql
# For counter metrics
sum(rate(good_metric[5m])) / sum(rate(total_metric[5m]))

# For gauge metrics  
sum(avg_over_time(good_metric[5m])) / sum(avg_over_time(total_metric[5m]))
```

### 2. Proper Burn Rate Formula
```promql
# Error budget ratio (how much of budget consumed)
1 - sli_measurement

# Burn rate (rate of budget consumption)
error_budget_ratio / error_budget_target
```

Where `error_budget_target = 1 - target`

### 3. Target Validation
Reject targets >= 1.0 or <= 0:
```go
func validateTarget(target float64) error {
    if target >= 1.0 {
        return errors.Permanent("target must be less than 1.0 (100%%)")
    }
    if target <= 0 {
        return errors.Permanent("target must be greater than 0")
    }
    return nil
}
```

### 4. Correct Window Pairs
Following Google SRE workbook multi-burn-rate approach:

| Severity | Short Window | Long Window | Threshold |
|----------|-------------|-------------|-----------|
| PageCritical | 5m | 1h | 14.4x |
| PageHigh | 30m | 6h | 6x |
| TicketHigh | 2h | 24h | 3x |
| TicketMedium | 6h | 3d | 1x |

### 5. Counter/Gauge Detection
```go
if sli.Spec.RatioMetric.Counter {
    // Counter: use rate()
    goodExpr = fmt.Sprintf("sum(rate(%s[%s]))", good, window)
} else {
    // Gauge: use avg_over_time()
    goodExpr = fmt.Sprintf("sum(avg_over_time(%s[%s]))", good, window)
}
```

### 6. Label Consistency
All aggregations now use `without()` grouping to preserve slo_name and sli_name labels.

### 7. Empty Rules Validation
Added `validateBurnRateWindows()` to ensure all required recording rules exist before generating alerts.

## Consequences

### Positive
- **Accurate SLO measurements**: Error ratios now correctly calculated per window
- **Correct burn rate alerts**: Following industry best practices
- **No crashes**: Division by zero prevented at validation time
- **Support for gauge metrics**: Can now handle both counter and gauge SLIs
- **Better test coverage**: 17 tests covering all calculation scenarios

### Negative
- **Breaking change**: Alert names changed from `slo-alert-page` to `slo_alert_page_critical`
- **Recording rule changes**: Rule format changed, existing rules need regeneration

### Migration
1. Delete existing PrometheusRules generated by OSKO
2. Upgrade operator
3. Let operator regenerate rules with correct calculations

## Implementation

- **Files changed**:
  - `internal/helpers/prometheus_helper.go` - Core calculation fixes
  - `internal/helpers/prometheus_helper_test.go` - Comprehensive tests (17 tests)
  - `internal/errors/errors.go` - Added `ValidationError`

- **Tests added**:
  - `TestValidateTarget`
  - `TestParseTarget`
  - `TestSetupRules_TargetValidation`
  - `TestSetupRules_CounterMetrics`
  - `TestSetupRules_GaugeMetrics`
  - `TestSetupRules_BurnRateFormula`
  - `TestSetupRules_ExtendedWindowUsesIndependentRate`
  - `TestBurnRateWindows_HasWindows`
  - `TestSetupRules_MagicAlerting_WindowPairs`
  - `TestSetupRules_MagicAlerting_CorrectWindowPairs`
  - `TestSetupRules_BadMetric`

## References

- [Google SRE Workbook - Alerting on SLOs](https://sre.google/workbook/alerting-on-slos/)
- [Sloth - SLO Generator](https://github.com/slok/sloth)
- [Prometheus Recording Rules Best Practices](https://prometheus.io/docs/practices/rules/)
